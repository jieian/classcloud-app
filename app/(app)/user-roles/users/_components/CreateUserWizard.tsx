"use client";

import { useState, useEffect, useRef } from "react";
import { useRouter } from "next/navigation";
import { Container, Stepper, Button, Group, Text, rem } from "@mantine/core";
import { useMediaQuery } from "@mantine/hooks";
import { useForm } from "@mantine/form";
import { modals } from "@mantine/modals";
import { notifications } from "@mantine/notifications";
import StepUserInfo from "./StepUserInfo";
import StepAssignRole from "./StepAssignRole";
import StepReview from "./StepReview";
import { validateCreateUserForm } from "../_lib/validation";
import { createUser, checkEmailExists, fetchAllRoles } from "../_lib";
import { toTitleCase, generateSecurePassword } from "../_lib/utils";
import type { CreateUserForm } from "../_lib/types";
import type { Role } from "../_lib/userRolesService";

export default function CreateUserWizard() {
  const router = useRouter();
  const [loading, setLoading] = useState(false);
  const [availableRoles, setAvailableRoles] = useState<Role[]>([]);
  const [loadingRoles, setLoadingRoles] = useState(false);

  const form = useForm<CreateUserForm>({
    validateInputOnChange: true,
    initialValues: {
      first_name: "",
      middle_name: "",
      last_name: "",
      email: "",
      passwordType: "manual",
      password: "",
      generatedPassword: undefined,
      role_ids: [],
      activeStep: 0,
    },
    validate: validateCreateUserForm,
  });

  // Load roles once for both StepAssignRole and StepReview
  useEffect(() => {
    loadRoles();
  }, []);

  async function loadRoles() {
    try {
      setLoadingRoles(true);
      const roles = await fetchAllRoles();
      setAvailableRoles(roles);
    } catch (error) {
      const errorMessage =
        error instanceof Error
          ? error.message
          : "Failed to load roles. Please try again.";
      notifications.show({
        title: "Error Loading Roles",
        message: errorMessage,
        color: "red",
        autoClose: 10000,
      });
    } finally {
      setLoadingRoles(false);
    }
  }

  // Warn user before leaving with unsaved changes
  useEffect(() => {
    const handleBeforeUnload = (e: BeforeUnloadEvent) => {
      if (form.isDirty()) {
        e.preventDefault();
        e.returnValue = "";
      }
    };

    window.addEventListener("beforeunload", handleBeforeUnload);
    return () => {
      window.removeEventListener("beforeunload", handleBeforeUnload);
    };
  }, [form.isDirty()]);

  const [checkingEmail, setCheckingEmail] = useState(false);
  const busyRef = useRef(false);
  const verifiedEmailRef = useRef<string | null>(null);

  const nextStep = async () => {
    // Guard against spam clicks — ref is synchronous, not batched like state
    if (busyRef.current) return;

    if (form.values.activeStep === 0) {
      // Validate Step 1 fields only
      const validation = form.validate();
      const step1HasErrors =
        validation.errors.first_name ||
        validation.errors.last_name ||
        validation.errors.email ||
        validation.errors.middle_name ||
        (form.values.passwordType === "manual" && validation.errors.password);

      if (step1HasErrors) {
        notifications.show({
          title: "Validation Error",
          message: "Please fix all errors before proceeding.",
          color: "red",
        });
        return;
      }

      // Check email uniqueness — skip if same email was already verified
      const trimmedEmail = form.values.email.trim();
      if (verifiedEmailRef.current !== trimmedEmail) {
        busyRef.current = true;
        setCheckingEmail(true);
        try {
          const emailTaken = await checkEmailExists(trimmedEmail);
          if (emailTaken) {
            form.setFieldError("email", "This email is already in use");
            notifications.show({
              title: "Email Already In Use",
              message:
                "This email is already registered. Please use a different email.",
              color: "red",
            });
            return;
          }
          // Cache verified email so going back + forward skips the check
          verifiedEmailRef.current = trimmedEmail;
        } catch {
          notifications.show({
            title: "Error",
            message: "Failed to verify email. Please try again.",
            color: "red",
          });
          return;
        } finally {
          busyRef.current = false;
          setCheckingEmail(false);
        }
      }

      // Generate password if autogenerated
      if (form.values.passwordType === "autogenerated") {
        const generated = generateSecurePassword();
        form.setFieldValue("generatedPassword", generated);
      }
    } else if (form.values.activeStep === 1) {
      // Validate Step 2 — at least one role
      const validation = form.validate();
      if (validation.errors.role_ids) {
        notifications.show({
          title: "Validation Error",
          message: "Please select at least one role.",
          color: "red",
        });
        return;
      }
    }

    form.setFieldValue("activeStep", form.values.activeStep + 1);
  };

  const prevStep = () => {
    form.setFieldValue("activeStep", form.values.activeStep - 1);
  };

  const handleCancel = () => {
    if (form.isDirty()) {
      modals.openConfirmModal({
        title: "Discard changes?",
        children: (
          <Text size="sm">
            You have unsaved changes. Are you sure you want to leave?
          </Text>
        ),
        labels: { confirm: "Discard", cancel: "Stay" },
        confirmProps: { color: "red" },
        onConfirm: () => {
          form.reset();
          router.replace("/user-roles/users");
          router.refresh();
        },
      });
    } else {
      router.replace("/user-roles/users");
      router.refresh();
    }
  };

  const handleCreateUser = () => {
    modals.openConfirmModal({
      title: "Create New User?",
      children: (
        <Text size="sm">
          This will create an account for{" "}
          <strong>
            {form.values.first_name} {form.values.last_name}
          </strong>{" "}
          with {form.values.role_ids.length} role(s).
        </Text>
      ),
      labels: { confirm: "Create User", cancel: "Cancel" },
      confirmProps: { style: { backgroundColor: "#4EAE4A" } },
      onConfirm: async () => {
        await submitForm();
      },
    });
  };

  const submitForm = async () => {
    try {
      setLoading(true);

      const trimmedEmail = form.values.email.trim();

      // Determine password to use
      const passwordToUse =
        form.values.passwordType === "autogenerated"
          ? form.values.generatedPassword!
          : form.values.password;

      const userData = {
        first_name: toTitleCase(form.values.first_name.trim()),
        middle_name: form.values.middle_name.trim()
          ? toTitleCase(form.values.middle_name.trim())
          : null,
        last_name: toTitleCase(form.values.last_name.trim()),
        email: trimmedEmail,
        password: passwordToUse,
        role_ids: form.values.role_ids.map((id) => parseInt(id)),
      };

      await createUser(userData);

      notifications.show({
        title: "Success",
        message: `User ${userData.first_name} ${userData.last_name} created successfully.`,
        color: "green",
      });

      form.reset();
      router.replace("/user-roles/users");
      router.refresh();
    } catch (error) {
      console.error("User creation error:", error);
      const message =
        error instanceof Error
          ? error.message
          : "Failed to create user. Please try again.";
      notifications.show({
        title: "Error",
        message,
        color: "red",
        autoClose: false,
      });
    } finally {
      setLoading(false);
    }
  };

  // Compute whether the Next button should be enabled for the current step
  const isNextDisabled = (() => {
    if (form.values.activeStep === 0) {
      const { first_name, last_name, email, password, passwordType } =
        form.values;
      const hasRequiredFields =
        first_name.trim() !== "" &&
        last_name.trim() !== "" &&
        email.trim() !== "" &&
        (passwordType === "autogenerated" || password !== "");
      const hasErrors = !!(
        form.errors.first_name ||
        form.errors.last_name ||
        form.errors.email ||
        form.errors.middle_name ||
        (passwordType === "manual" && form.errors.password)
      );
      return !hasRequiredFields || hasErrors;
    }
    if (form.values.activeStep === 1) {
      return form.values.role_ids.length === 0;
    }
    return false;
  })();

  const isMobile = useMediaQuery("(max-width: 768px)");

  return (
    <Container size="xl" py="xl">
      {isMobile ? (
        // Mobile: Stacked layout
        <>
          <Stepper
            active={form.values.activeStep}
            color="#4EAE4A"
            orientation="vertical"
          >
            <Stepper.Step label="Step 1" description="Specify user information">
              <StepUserInfo form={form} />
            </Stepper.Step>

            <Stepper.Step label="Step 2" description="Assign Role">
              <StepAssignRole
                form={form}
                availableRoles={availableRoles}
                loadingRoles={loadingRoles}
              />
            </Stepper.Step>

            <Stepper.Step label="Step 3" description="Review and Create User">
              <StepReview form={form} availableRoles={availableRoles} />
            </Stepper.Step>
          </Stepper>

          {/* Navigation Buttons */}
          <Group justify="flex-end" mt="xl">
            <Button variant="default" onClick={handleCancel}>
              Cancel
            </Button>

            {form.values.activeStep > 0 && (
              <Button variant="outline" onClick={prevStep}>
                Previous
              </Button>
            )}

            {form.values.activeStep < 2 ? (
              <Button
                onClick={nextStep}
                disabled={isNextDisabled}
                loading={checkingEmail}
                style={
                  isNextDisabled ? undefined : { backgroundColor: "#4EAE4A" }
                }
              >
                Next
              </Button>
            ) : (
              <Button
                onClick={handleCreateUser}
                loading={loading}
                style={{ backgroundColor: "#4EAE4A" }}
              >
                Create User
              </Button>
            )}
          </Group>
        </>
      ) : (
        // Desktop: Side-by-side layout
        <div style={{ display: "flex", gap: rem(32) }}>
          {/* Left side: Stepper */}
          <div style={{ flexShrink: 0, width: "250px" }}>
            <Stepper
              active={form.values.activeStep}
              color="#4EAE4A"
              orientation="vertical"
            >
              <Stepper.Step
                label="Step 1"
                description="Specify user information"
              />
              <Stepper.Step label="Step 2" description="Assign Role" />
              <Stepper.Step
                label="Step 3"
                description="Review and Create User"
              />
            </Stepper>
          </div>

          {/* Right side: Content */}
          <div style={{ flex: 1 }}>
            {form.values.activeStep === 0 && <StepUserInfo form={form} />}
            {form.values.activeStep === 1 && (
              <StepAssignRole
                form={form}
                availableRoles={availableRoles}
                loadingRoles={loadingRoles}
              />
            )}
            {form.values.activeStep === 2 && (
              <StepReview form={form} availableRoles={availableRoles} />
            )}

            {/* Navigation Buttons */}
            <Group justify="flex-end" mt="xl">
              <Button variant="default" onClick={handleCancel}>
                Cancel
              </Button>

              {form.values.activeStep > 0 && (
                <Button variant="outline" onClick={prevStep}>
                  Previous
                </Button>
              )}

              {form.values.activeStep < 2 ? (
                <Button
                  onClick={nextStep}
                  disabled={isNextDisabled}
                  style={
                    isNextDisabled ? undefined : { backgroundColor: "#4EAE4A" }
                  }
                >
                  Next
                </Button>
              ) : (
                <Button
                  onClick={handleCreateUser}
                  loading={loading}
                  style={{ backgroundColor: "#4EAE4A" }}
                >
                  Create User
                </Button>
              )}
            </Group>
          </div>
        </div>
      )}
    </Container>
  );
}
